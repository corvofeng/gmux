{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kubemux","text":"<p>A tmux wrapper for managing multiple clusters and incorporating tmuxinator.</p> <p>For this project, I heavily relied on ChatGPT, mainly for writing the logic and unit tests. Originally, I thought it would take 2-3 days of work, but the development cycle was shortened to 1 day. The final result is also very good. After rewriting, kubemux has no dependencies and is very lightweight to install.</p> <p>The project is open source here, and it should be compatible with tmuxinator configurations. If you find any missing features, feel free to open an issue.</p> <p>https://github.com/corvofeng/kubemux</p> English Documents \u4e2d\u6587\u6587\u6863 introduction \u7b80\u4ecb comments \u6ce8\u91ca\u529f\u80fd\u7684\u4f7f\u7528 example snips \u793a\u4f8b\u4ee3\u7801\u7247\u6bb5 available commands Vsnips\u53ef\u7528\u7684\u547d\u4ee4 available config Vsnips\u53ef\u7528\u7684\u914d\u7f6e\u9879"},{"location":"en/example/","title":"Best Practice","text":""},{"location":"en/example/#kube-ps1","title":"kube-ps1","text":"<p>If you want to use kubectl with zsh, I recommend to use <code>kube-ps1</code></p> <p>https://github.com/jonmosco/kube-ps1</p> <p></p> <pre><code># For zsh\nplugins=(\n  kube-ps1\n)\n\nPROMPT='$(kube_ps1)'$PROMPT # or RPROMPT='$(kube_ps1)'\n</code></pre>"},{"location":"en/example/#fzf","title":"fzf","text":"<p>A good search engine in the terminal</p> <p>https://github.com/junegunn/fzf</p> <pre><code>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf &amp;&amp; \\\n    ~/.fzf/install --bin  &amp;&amp; ~/.fzf/install --completion --update-rc --key-bindings --no-bash --no-fish  &amp;&amp; \\\n    grep  -q 'fzf.zsh' ~/.zshrc || echo '[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zsh' &gt;&gt; ~/.zshrc\n</code></pre>"},{"location":"en/example/#k9s","title":"k9s","text":"<p>https://k9scli.io/topics/commands/</p> <p>k9s will use the kubemux environment, and will not impact other context.</p> <p></p> <pre><code>bin install https://github.com/derailed/k9s\n   \u2022 Getting latest release for derailed/k9s\n\nMultiple matches found, please select one:\n\n [1] k9s_Linux_amd64.tar.gz\n [2] k9s_Linux_amd64.tar.gz.sbom\n [3] k9s_linux_amd64.apk\n Select an option: 1\n   \u2022 Starting download of https://api.github.com/repos/derailed/k9s/releases/assets/157727973\n28.58 MiB / 28.58 MiB [------------------------------------------------------------------------] 100.00% 7.94 MiB p/s 4s\n\nMultiple matches found, please select one:\n\n [1] LICENSE\n [2] README.md\n [3] k9s\n Select an option: 3\n   \u2022 Copying for k9s@v0.32.4 into /home/corvo/.local/bin/k9s\n   \u2022 Done installing k9s v0.32.4\n</code></pre>"},{"location":"en/example/#tmuxinator-example-template","title":"tmuxinator example template","text":"<pre><code>name: &lt;%= @settings[\"project\"] %&gt;\nroot: ~/GitRepo\n\nsocket_name: &lt;%= @settings[\"project\"] %&gt;\non_project_start:\n\n  # Since a jump host is needed to connect to the API,\n  # I used ssh to open a socks5 proxy on my local machine.\n  # The following method is used to obtain a locally available port and the corresponding jump host:\n  - export KUBECONFIG=~/.kube/config-&lt;%= @settings[\"project\"] %&gt;\n  - export TMUX_SSH_PORT=\"$(python3 -c 'import socket; s=socket.socket(); s.bind((\"\", 0)); print(s.getsockname()[1])')\"\n  - export TMUX_SSH_HOST=\"&lt;%= @settings[\"host\"] %&gt;\"\nstartup_window: kubectl\n\nwindows:\n  - proxy:\n      layout: main-vertical\n      panes:\n        - startup:\n          - ls -alh\n          - yq -i e '.current-context |= \"tpl-&lt;%= @settings[\"project\"] %&gt;\"' $KUBECONFIG\n          - yq -i e '.contexts[0].name |= \"tpl-&lt;%= @settings[\"project\"] %&gt;\"' $KUBECONFIG\n          - yq -i e \".clusters[0].cluster.proxy-url |=\\\"socks5://127.0.0.1:$TMUX_SSH_PORT\\\"\" $KUBECONFIG\n          - ssh -D $TMUX_SSH_PORT $TMUX_SSH_HOST\n  - kubectl: ls # kubectl get pods\n</code></pre> <p>In addition to modifying the context, you can also add prompts to the terminal PS1, similar to this:</p> <p></p>"},{"location":"en/intro/","title":"Introduction","text":""},{"location":"en/intro/#installation","title":"Installation","text":""},{"location":"en/intro/#macos","title":"MacOS","text":"<pre><code>brew install corvofeng/tap/kubemux\n</code></pre>"},{"location":"en/intro/#linux","title":"Linux","text":"<p>Using bin: https://github.com/marcosnils/bin</p> <pre><code>bin install https://github.com/corvofeng/kubemux ~/usr/bin\n# bin ls\n# Path                  Version  URL                                                       Status\n# ~/usr/bin/kubemux     v1.1.2   https://github.com/corvofeng/kubemux/releases/tag/v1.1.2  OK\n</code></pre> <p>Using binary</p> <pre><code>cd /tmp\nrm kubemux_linux_amd64.tar.gz\nwget https://github.com/corvofeng/kubemux/releases/latest/download/kubemux_linux_amd64.tar.gz\ntar -zxvf kubemux_linux_amd64.tar.gz\nsudo install -v kubemux /usr/local/bin\n</code></pre>"},{"location":"en/usage/","title":"How to use kubemux","text":""},{"location":"en/usage/#tmuxinator","title":"tmuxinator","text":"<p>kubemux supports the tmuxinator configuration and template, which was the original inspiration behind kubemux.</p> <pre><code>mkdir ~/.tmuxinator\n\necho '\nname: kubemux\nroot: \"~/\"\nwindows:\n  - p1:\n    - ls\n    - pwd\n  - p2:\n    - pwd\n    - echo \"hello world\"\n  - p3: htop\n' &gt; ~/.tmuxinator/kubemux.yml\n\nkubemux -p kubemux\n</code></pre>"},{"location":"en/usage/#kubeconfig","title":"kubeconfig","text":"<p>As I used this project more, I found that I didn't need excessive customization for tmux, but simply to open the kubeconfig I desired. Therefore, I extended the project itself to better support kubeconfig configurations. I also added support for auto-completion, making it quicker to use your Kubernetes cluster now.</p> <pre><code>ls ~/.kube\n# pve-kube.config xxx\n\nkubemux kube --kube pve-kube.config\n\n# I suggest you add the completion support\n#   source &lt;(kubemux completion bash)\n#   source &lt;(kubemux completion zsh)\n# or you can add the command into the .bashrc or .zshrc.\nkubemux kube --kube &lt;tab&gt;\n</code></pre>"},{"location":"en/why/","title":"Why I create this tool","text":""},{"location":"en/why/#kubernetes-multi-cluster-management-solution","title":"Kubernetes Multi-Cluster Management Solution","text":"<p>The official Kubernetes website provides a solution for switching between clusters using the context in KUBECONFIG.</p> <p>https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/</p> <pre><code>apiVersion: v1\nkind: Config\npreferences: {}\n\nclusters:\n- cluster:\n  name: development\n- cluster:\n  name: test\n\nusers:\n- name: developer\n- name: experimenter\n\ncontexts:\n- context:\n  name: dev-frontend\n- context:\n  name: dev-storage\n- context:\n  name: exp-test\n</code></pre> <p>Many existing tools for managing multiple Kubernetes clusters, such as kubecm, rely on maintaining a single KUBECONFIG file. This approach has several drawbacks:</p> <ol> <li>KUBECONFIG file maintenance: Adding and deleting clusters requires manually editing the KUBECONFIG file, which can become tedious and error-prone, especially when managing a large number of clusters.</li> <li>ingle-cluster operation: Since all clusters are configured in the same KUBECONFIG file, only one cluster can be operated on at a time. This can be inconvenient and inefficient in a multi-cluster management environment.</li> </ol> <p>Solution using tmux configuration file splitting:</p> <p>To address these problems, I propose a solution that utilizes tmux configuration file splitting. This approach involves creating a separate tmux session for each Kubernetes cluster. Each tmux session has its own KUBECONFIG file, which allows you to operate on multiple clusters simultaneously and independently.</p>"},{"location":"en/why/#tmux","title":"tmux","text":"<p><code>tmux</code> is a powerful terminal multiplexer that allows you to create and manage multiple sessions in the same terminal window. This is very useful for managing multiple servers or clusters because you can easily switch between different sessions without opening multiple terminal windows.</p> <p>To use tmux, you need to install it first. In most Linux distributions, you can install tmux using the following command:</p> <pre><code>sudo apt install tmux\n</code></pre> <p>After the installation is complete, you can start tmux using the following command:</p> <pre><code>tmux\n</code></pre> <p>This will create a new tmux session in your terminal window. You can use the following command to switch between different sessions:</p> <pre><code>tmux attach-session -t &lt;session-name&gt;\ntmux new-session -s &lt;session-name&gt;\n</code></pre>"},{"location":"en/why/#multiple-sessions","title":"Multiple Sessions","text":"<p>In simple terms, the <code>-L socket-name</code> parameter allows you to specify the location of the tmux socket, and different sockets correspond to completely isolated sessions.</p> <p>We can use different environment variables in different sessions to achieve environment separation.</p> <p>For example, with the following two commands, you can create two completely independent terminals with their own environment variables:</p> <pre><code>KUBECONFIG=~/.kube/config-aa tmux -L aa\nKUBECONFIG=~/.kube/config-bb tmux -L bb\n</code></pre> <p>The script here can already achieve multi-cluster management. So why do we introduce tmuxinator and my new tool kubemux?</p> <ol> <li>The configuration for the production environment needs to go through a jump host. How can we use KUBECONFIG locally? (I have attached it at the end)</li> <li>I want the tmux session to have multiple windows with their own functionalities.</li> </ol>"},{"location":"en/why/#tmuxinator","title":"tmuxinator","text":"<p>https://github.com/tmuxinator/tmuxinator</p> <p></p> <p>It is a tool written in Ruby that allows you to define tmux terminals in YAML format. It also supports templating. Here is an example of a templated YAML file:</p>"},{"location":"en/why/#usage","title":"Usage","text":"<pre><code>name: project\nroot: ~/&lt;%= @settings[\"workspace\"] %&gt;\n# tmuxinator start project workspace=~/workspace/todo\n\nwindows:\n  - small_project:\n      root: ~/projects/company/small_project\n      panes:\n        - start this\n        - start that\n</code></pre> <p>During the months of managing cluster environment migration, some of the most frequently used commands were:</p> <pre><code>tmuxinator tpl project=ingame-pre-na\ntmuxinator tpl project=ingame-pre-sg\ntmuxinator tpl project=ingame-pre-fra\n</code></pre> <p>It can help me perfectly differentiate different environments, and because I use fzf, I can even fuzzy search for the environment I want to open.</p> <p></p>"},{"location":"en/why/#limitation","title":"Limitation","text":"<p>Since it is written in Ruby, it requires a relatively new version of Ruby installed on the machine. AWS requires logging into a jump host for operations, but the machines we use are very old, and I don't want to compile and reinstall Ruby. After a quick look at the code, I found that it doesn't use any advanced features. It would be very easy to completely rewrite it in Golang.</p>"}]}